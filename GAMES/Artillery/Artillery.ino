
#include <Arduboy2.h>
#include <ArduboyTones.h>

 const unsigned char main_menu [] = {
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x7f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x3f, 0x3f, 
0x3f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x3f, 
0x3f, 0x3f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 
0x07, 0x01, 0x00, 0x00, 0x80, 0xc0, 0x80, 0x00, 
0x00, 0x03, 0x07, 0x1f, 0x7f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 
0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x1f, 0x3f, 
0xff, 0xff, 0xff, 0xff, 0xbf, 0x1f, 0x1f, 0x1f, 
0x3f, 0xff, 0xff, 0x3f, 0x1f, 0x1f, 0x1f, 0xff, 
0xff, 0xff, 0xff, 0x1f, 0x1f, 0x1f, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x3f, 0x03, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x0f, 0x0f, 0x0f, 0x0e, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x07, 
0x0f, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x07, 0x0f, 0x07, 0x07, 0x07, 0x03, 0x03, 
0x01, 0x00, 0xc0, 0xc0, 0xe0, 0xf8, 0xfe, 0xff, 
0xff, 0xe7, 0xc7, 0xc3, 0x00, 0x00, 0x00, 0x00, 
0xc7, 0xc3, 0xc7, 0xff, 0xff, 0x02, 0x02, 0x02, 
0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 
0xff, 0x1f, 0x0f, 0x07, 0x87, 0x87, 0xc3, 0x43, 
0x03, 0x07, 0x07, 0x0f, 0xff, 0xff, 0xe7, 0x07, 
0x07, 0x07, 0x07, 0x83, 0xc3, 0xc3, 0x83, 0x83, 
0xc7, 0xff, 0x83, 0x03, 0x03, 0x07, 0x3f, 0xff, 
0xff, 0xff, 0x1f, 0x03, 0x03, 0x03, 0xe7, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x9f, 0x01, 0x00, 0x00, 0x00, 0x00, 
0xf8, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 
0xfe, 0xfe, 0xfe, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x02, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xf0, 0xe0, 
0xc0, 0x80, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 
0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x80, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 
0x80, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x1f, 
0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x08, 0x3f, 
0xff, 0xe0, 0x80, 0x80, 0x00, 0x08, 0x08, 0x08, 
0x0c, 0x84, 0x86, 0xc6, 0xe7, 0xff, 0xff, 0x80, 
0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0xfc, 0x78, 0x30, 0x00, 
0x01, 0x00, 0xc0, 0xf0, 0xfc, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xdf, 0xdf, 0xdf, 0x5e, 0x5e, 0x5e, 0x5e, 0x5f, 
0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 
0xdf, 0x5f, 0x5f, 0x5f, 0x5e, 0x5e, 0xde, 0xde, 
0xde, 0xdf, 0xdf, 0xdf, 0xde, 0xdc, 0xdc, 0xde, 
0xde, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 
0xdf, 0xdf, 0xdf, 0xde, 0xdc, 0xdc, 0xde, 0xdf, 
0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 
0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 
0xdf, 0xdf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 
0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 
0xcf, 0x0f, 0x9f, 0xdf, 0xdf, 0x9f, 0x3f, 0xff, 
0xff, 0xff, 0x7f, 0xff, 0xff, 0x7f, 0xff, 0xff, 
0xff, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 
0x7f, 0x7f, 0x7f, 0x7f, 0x79, 0x78, 0x78, 0x78, 
0x7c, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 
0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x80, 0xb3, 0xb3, 0xb3, 0x80, 
0xcc, 0xff, 0x61, 0x4f, 0x4f, 0x81, 0xff, 0xff, 
0xff, 0x80, 0x80, 0xbb, 0xb3, 0xb3, 0xc4, 0xff, 
0xc3, 0xa5, 0xa5, 0xa1, 0xa3, 0xff, 0x81, 0xf3, 
0xf9, 0xfd, 0xfd, 0x63, 0x63, 0x5d, 0x4d, 0x81, 
0xff, 0xdf, 0xad, 0xa5, 0xa1, 0x83, 0xff, 0xb3, 
0xa5, 0xa5, 0xcd, 0xff, 0x81, 0x81, 0xf9, 0xc3, 
0xfd, 0x83, 0xff, 0xb3, 0xb1, 0xa5, 0x8d, 0xcd, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xc0, 0x0c, 0x7f, 0xff, 0xff, 0x7f, 0x0c, 0x80, 
0xff, 0xff, 0x80, 0xff, 0xff, 0x80, 0xff, 0xff, 
0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x9f, 0x9e, 0xec, 0xe1, 0xff, 0xff, 0xff, 0xff, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3f, 0x3f, 
0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 

};

/*
  README.  

  This is a
*/

/*
unsigned char modified_buf [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
*/

 const unsigned char solid [] = {
  0xFF,0xFF,0xFF,0xDF,0xFF,0xFF,0xFF,0xFF
};

typedef struct Artillery {
  unsigned char xpos;
  unsigned char ypos;
  unsigned char angle;
  unsigned char health;
  unsigned char max_health;
} Artillery;

typedef struct Projectile {
  double xpos;
  double ypos;
  double x_step;
  double y_step;  
} Projectile;

typedef struct Game {
  Artillery player_a;
  Artillery player_b; 
  Projectile projectile;
  unsigned char state; 
  unsigned char strength;
  signed char wind;
  signed char wind_tgt;
  float sine_wave;
  unsigned char ai_angle;
  unsigned char ai_power;
} Game;

//enough for ? of height, top 3 must be sky, bottom 2 is bedrock
unsigned char *modified_buf;

#define MODIFIABLE_DEPTH 3
#define GROUND_THICKNESS 2
#define LEVEL_WIDTH 256
#define START_Y 6
#define TANK_WIDTH 6
#define BARREL_LENGTH 6
#define MAX_STRENGTH 16
#define MAX_HEALTH 56
#define MIN_HEALTH 10
#define MAX_WIND 7
#define AI_TRIES 5

unsigned short view_x;
unsigned char game_state;
unsigned char button_state;

#define BS_A 0x01
#define BS_B 0x02

#define BS_up 0x04
#define BS_down 0x08
#define BS_left 0x10
#define BS_right 0x20

#define GS_MAIN_MENU 0x01
#define GS_GAME_PARAMS 0x02
#define GS_GAME_PLAYING 0x04
#define GS_GAME_COMPLETE 0x08
#define GS_ALLOW_WIND 0x10
#define GS_AI_PLAYER 0x20


#define PS_PLAYER_1 0x01
#define PS_PLAYER_2 0x02
#define PS_PROJECTIL_FOLLOW 0x04
#define PS_PLAYER_PAN 0x08

#define OPT_WIND 0x00
#define OPT_PLAYER 0x01
#define OPT_HEALTH 0x02

Game game;
Arduboy2 arduboy;
ArduboyTones sound(arduboy.audio.enabled);
  
void inogamesetup() {
  // put your setup code here, to run once:
  arduboy.begin();
  modified_buf = (unsigned char*)calloc(sizeof(unsigned char),LEVEL_WIDTH * MODIFIABLE_DEPTH);
  game_state = GS_MAIN_MENU;
  
  srand(micros());
  arduboy.initRandomSeed();

  Serial.begin(9600);
  
  
  view_x = 0;   
  button_state = 0;

  game.state = PS_PLAYER_1;
}

void zeroLevel() {
  for(int iter =0; iter < LEVEL_WIDTH * MODIFIABLE_DEPTH; iter++) {
    modified_buf[iter] = 0;
  }
}

/*
X = 0 - 255
Y = 0 - 2
val = 0x00 - 0xFF
*/
void setMemAt(unsigned char x, unsigned char y, unsigned char val) {
  modified_buf[x*3 + y] = val;
}

unsigned char getMemAt(unsigned char x, unsigned char y) {
  return modified_buf[x*3 + y];
}

unsigned char checkMem(unsigned char x, unsigned char y) {
  if(y >= MODIFIABLE_DEPTH*8) { return 0; }
  unsigned long block_a = getMemAt(x,2);  
  unsigned long block_b = getMemAt(x,1); 
  unsigned long block_c = getMemAt(x,0); 

  unsigned long byte_pack = block_c; byte_pack |= (block_b << 8);  byte_pack |= (block_a << 16);
  return (byte_pack & (1L << y)) == 0 ? 0 : 1;
}

//returns true when updates were made
unsigned char update_dirt() {

  unsigned char any_update = 1;

  if(arduboy.everyXFrames(4)) {
    
    any_update = 0;
    for(unsigned short iter=0; iter<LEVEL_WIDTH; iter++) {
      unsigned long block_a = getMemAt(iter,2);  
      unsigned long block_b = getMemAt(iter,1); 
      unsigned long block_c = getMemAt(iter,0); 

      unsigned long byte_pack = block_c; byte_pack |= (block_b << 8);  byte_pack |= (block_a << 16);
      
      if(byte_pack==0) { continue; }
      
      unsigned char ptr = 0;
      while((byte_pack & (0x1L << ptr)) !=0 && ptr < 24){ ptr++; }

      //all full
      if(ptr==24) { continue; }

      unsigned long masker = 0x1L << (ptr);
      masker--;
      masker = ~masker; 
      unsigned long shifter = byte_pack & (masker);
      
      if(shifter == 0) { continue; }
      shifter = shifter >> 1;
      byte_pack &= (~masker);
      byte_pack |= shifter;
      
      setMemAt(iter,2,(unsigned char)((byte_pack >> 16)&0xFF));
      setMemAt(iter,1,(unsigned char)((byte_pack >> 8)&0xFF));
      setMemAt(iter,0,(unsigned char)((byte_pack)&0xFF));
      
    }
  }
  
  return any_update;
}

void sculptLevel() {
  unsigned char aimy = START_Y;
  unsigned char drawpty = START_Y;
  unsigned char change_y = 12;
  unsigned char up = 0;
  unsigned char next_choice = 10;
  
  for(unsigned short i=0; i<LEVEL_WIDTH; i++){
    change_y = drawpty;
    up = 0;

    drawpty = drawpty < aimy ? drawpty+1 : drawpty > aimy ? drawpty-1 : drawpty;
    next_choice--;
    if(next_choice==0) {
      aimy = (aimy<6)?aimy+(rand()%8) : (aimy>(MODIFIABLE_DEPTH*8-6))?aimy-(rand()%8) : aimy+((rand()%11 - 4)); 
      next_choice = 10 + (rand()%4);
      if(i + next_choice > LEVEL_WIDTH - 16) {
        aimy = START_Y + (rand()%5) - 2;  
      }
      if(i + next_choice > LEVEL_WIDTH - 10) {
        aimy = START_Y;
      }
    }
    
    while(change_y > 7) {
      setMemAt(i,up,0xFF);
      change_y -= 8;  
      up++;
    }
    
    if(up==3){continue;}
    
    switch(change_y) {
      case 0: setMemAt(i,up,0x00); break;
      case 1: setMemAt(i,up,0x01); break;
      case 2: setMemAt(i,up,0x03); break;
      case 3: setMemAt(i,up,0x07); break;
      case 4: setMemAt(i,up,0x0F); break;
      case 5: setMemAt(i,up,0x1F); break;
      case 6: setMemAt(i,up,0x3F); break;
      case 7: setMemAt(i,up,0x7F); break; 
    }
  }
}

void setupArtillery() {
  game.player_a.xpos = 2;
  game.player_a.ypos = 64 - GROUND_THICKNESS*8 - START_Y;
  game.player_a.angle = 0;
  game.player_a.health = game.player_a.max_health;

  game.player_b.xpos = LEVEL_WIDTH - TANK_WIDTH - 2;
  game.player_b.ypos = 64 - GROUND_THICKNESS*8 - START_Y;
  game.player_b.angle = 0;
  game.player_b.health = game.player_b.max_health;

  
  if(game_state & GS_ALLOW_WIND) {
    game.wind_tgt = rand() % (MAX_WIND+1);
    game.wind_tgt *= ((rand()%100) < 50) ? 1 : -1;
    game.wind = game.wind_tgt;
  } else {
    game.wind_tgt = 0;
    game.wind = 0;
  }
  
}

void inogameloop() {
  delay(0);
  
  if (!(arduboy.nextFrame()))
    return;

  //if(arduboy.everyXFrames(20)){Serial.print("Pulse"); Serial.println();}
  arduboy.clear();

  if(arduboy.pressed(A_BUTTON)) { button_state |= BS_A; }
  if(arduboy.pressed(B_BUTTON)) { button_state |= BS_B; }  

  if(game_state & GS_MAIN_MENU)           { draw_main_menu();     }
  else if(game_state & GS_GAME_PARAMS)    { draw_game_setup();    }
  else if(game_state & GS_GAME_PLAYING)   { draw_game_playing();  }
  else if(game_state & GS_GAME_COMPLETE)  { draw_game_complete(); }

  
  if(arduboy.notPressed(A_BUTTON)) { button_state &= ~BS_A; }
  if(arduboy.notPressed(B_BUTTON)) { button_state &= ~BS_B; }
  if(arduboy.notPressed(UP_BUTTON)) { button_state &= ~BS_up; }
  if(arduboy.notPressed(DOWN_BUTTON)) { button_state &= ~BS_down; }
  if(arduboy.notPressed(LEFT_BUTTON)) { button_state &= ~BS_left; }
  if(arduboy.notPressed(RIGHT_BUTTON)) { button_state &= ~BS_right; }

    
  //Serial.write(arduboy.getBuffer(), 128 * 64 / 8);
  arduboy.display();

}

void draw_main_menu() {
  arduboy.drawBitmap(0,0,main_menu,128,64,1);
  arduboy.setCursor(0,56);
  arduboy.print(F("Press A To Start"));
  if(button_state & BS_A && arduboy.notPressed(A_BUTTON)) {
      game_state = GS_GAME_PARAMS;
      game_state |= GS_ALLOW_WIND;
      game.strength = 0;
      game.wind = 20;
  }
}

void draw_game_setup() {
  arduboy.setCursor(0,0);
  arduboy.print(F("Game Settings"));
  arduboy.setCursor(0,56);
  arduboy.print(F("Press A To Start"));

  if((button_state & BS_up) == 0 && arduboy.pressed(UP_BUTTON)) {
    game.strength = game.strength > 0 ? game.strength-1 : 0;
    button_state |= BS_up;
  }
  
  if((button_state & BS_down) == 0 && arduboy.pressed(DOWN_BUTTON)) {
    game.strength = game.strength < 2 ? game.strength+1 : 2;
    button_state |= BS_down;
  }

  if((button_state & BS_left)==0 && arduboy.pressed(LEFT_BUTTON)) {
    button_state |= BS_left;
    if(game.strength == OPT_WIND) {
      game_state |= GS_ALLOW_WIND;
    } else if(game.strength == OPT_PLAYER) {
      game_state &= ~GS_AI_PLAYER;
    } 
  }

  if(arduboy.pressed(LEFT_BUTTON) && game.strength == OPT_HEALTH && arduboy.everyXFrames(3)) {
      game.wind = game.wind > MIN_HEALTH ? game.wind - 1 : MIN_HEALTH;
  }
  
  if((button_state & BS_right)==0  && arduboy.pressed(RIGHT_BUTTON)) {
    button_state |= BS_right;
    if(game.strength == OPT_WIND) {
      game_state &= ~GS_ALLOW_WIND;
    } else if(game.strength == OPT_PLAYER) {
      game_state |= GS_AI_PLAYER;
    }
  }

  if(arduboy.pressed(RIGHT_BUTTON) && game.strength == OPT_HEALTH && arduboy.everyXFrames(3)) {
      game.wind = game.wind < MAX_HEALTH ? game.wind + 1 : MAX_HEALTH;
  }

  arduboy.fillTriangle(3,13 + 10 * game.strength, 0,13 + 10 * game.strength - 2, 0,13 + 10 * game.strength + 2,WHITE);
  //draw options.
  arduboy.setCursor(6,10);
  arduboy.print(F("Wind:         "));
  arduboy.print((game_state & GS_ALLOW_WIND) ? F("YES") : F("NO"));
  
  arduboy.setCursor(6,20);
  arduboy.print(F("Opponent:     "));
  arduboy.print((game_state & GS_AI_PLAYER) ? F("AI") : F("HUMAN"));
  
  arduboy.setCursor(6,30);
  arduboy.print(F("Max Health:   "));
  unsigned char mhealth = game.wind;
  arduboy.print(mhealth);
  
  if(button_state & BS_A && arduboy.notPressed(A_BUTTON)) {

    game.player_a.max_health = game.wind;
    game.player_b.max_health = game.wind;
    game.strength = 0;
    
    zeroLevel();
    sculptLevel();
    setupArtillery();
    game_state &= ~GS_GAME_PARAMS;
    game_state |= GS_GAME_PLAYING;
  }

  //draw helper arrows
  if(game.strength == OPT_WIND) {
    if(game_state & GS_ALLOW_WIND) {
      arduboy.fillTriangle(123,11,125,13,123,15,WHITE);
    } else {
      arduboy.fillTriangle(82,13,84,11,84,15,WHITE);
    }
  } else if(game.strength == OPT_PLAYER) {
    if(game_state & GS_AI_PLAYER) {
      arduboy.fillTriangle(82,23,84,21,84,25,WHITE);
    } else {
      arduboy.fillTriangle(123,21,125,23,123,25,WHITE);
    }
  } else if(game.strength == OPT_HEALTH) {
    if(game.wind < MAX_HEALTH) {
      arduboy.fillTriangle(123,31,125,33,123,35,WHITE);
    } 
    if(game.wind > MIN_HEALTH) {
      arduboy.fillTriangle(82,33,84,31,84,35,WHITE);
    }
  }
}

void draw_game_complete() {

  arduboy.setCursor(0,0);
  if(game.player_a.health == 0) {
    arduboy.print(F("Player 2 Wins"));  
  }
  if(game.player_b.health == 0) {
    arduboy.print(F("Player 1 Wins"));  
  }
  
  if(button_state & BS_A && arduboy.notPressed(A_BUTTON)) {
    game_state = GS_MAIN_MENU;
  }
}

unsigned char checkArtillery(Artillery *a, unsigned char xx, unsigned char yy) {
  if(a->xpos <= xx && a->xpos + TANK_WIDTH >= xx) {
    if(64 - (8*GROUND_THICKNESS) - a->ypos <= yy && 64 - (8*GROUND_THICKNESS) - a->ypos + 4 >= yy) {
      return 1;
    }
  }
  return 0;
}

void checkArtilleryHit(unsigned char xx, unsigned char yy) {
  if(checkArtillery(&(game.player_a),xx,yy)) {
    game.player_a.health = game.player_a.health > 0 ? game.player_a.health - 1 : 0;
  }
  
  if(checkArtillery(&(game.player_b),xx,yy)) {
    game.player_b.health = game.player_b.health > 0 ? game.player_b.health - 1 : 0;
  }
}

void projectile_hit() {
  //flip bits around hit
  unsigned char y_hit_top = game.projectile.ypos + 4;
  unsigned char y_hit_btm = game.projectile.ypos >= 4 ? game.projectile.ypos - 4 : 0;
  y_hit_top = y_hit_top >= MODIFIABLE_DEPTH*8 ? MODIFIABLE_DEPTH*8-1 : y_hit_top;
  unsigned char x_hit_left = game.projectile.xpos < 4 ? 0 : game.projectile.xpos - 4;
  unsigned char x_hit_right = game.projectile.xpos >= LEVEL_WIDTH - 4 ? LEVEL_WIDTH : game.projectile.xpos + 4;

  for(unsigned char xx=x_hit_left; xx<x_hit_right; xx++){
    for(unsigned char yy= y_hit_btm; yy<y_hit_top; yy++){
      signed char xdif = (game.projectile.xpos - xx);
      signed char ydif = (game.projectile.ypos - yy);

      if(xdif*xdif + ydif*ydif > 9) { continue; }
      
      unsigned char memval = getMemAt(xx,yy/8);
      memval &= ~(1 << (yy%8));
      setMemAt(xx,yy/8,memval);  

      checkArtilleryHit(xx,yy);
    }
  }
  
}

void draw_game_playing() {
  
  if((game.state & PS_PROJECTIL_FOLLOW) == 0 && (game.state & PS_PLAYER_PAN) == 0) {

    
    if(arduboy.pressed(B_BUTTON)) {
      if(arduboy.pressed(LEFT_BUTTON)){
        view_x = view_x > 0 ? view_x - 1 : view_x;  
      }
    
      if(arduboy.pressed(RIGHT_BUTTON)){
        view_x = view_x < 127 ? view_x + 1 : view_x;
      }
    } else {
      view_x = game.state & PS_PLAYER_1 ? 0 : 127;
      handle_user_input_for_game();  
    }
  }

  if(game.state & PS_PROJECTIL_FOLLOW) {
    //make sure view_x tries to centre on projectile
      
    //if true, then projectile has impacted
    unsigned char update_result = update_projectile();
    if(update_result == 1) {
      game.state &= 0x03;
      game.state |= PS_PLAYER_PAN;
      game.strength = 60;
    } else if(update_result == 2) {

      //boom
      projectile_hit();
      
      if(game.player_a.health==0 || game.player_b.health==0) {
        game.state = PS_PLAYER_1;
        game_state = GS_GAME_COMPLETE;
      } else {
        game.state &= 0x03;
        game.state |= PS_PLAYER_PAN;
        game.strength = 60;
        if(game_state & GS_ALLOW_WIND) {
          game.wind_tgt = rand() % (MAX_WIND+1);
          game.wind_tgt *= ((rand()%100) < 50) ? 1 : -1;
        } else {
          game.wind_tgt = 0;
          game.wind = 0;
        }
        
      }
    } else {

      if(game.projectile.xpos < 64)                              { view_x = 0;         }
      else if(game.projectile.xpos > LEVEL_WIDTH - 64)           { view_x = 127;       }
      else                                                       { view_x = game.projectile.xpos - 64 > 127 ? 127 :game.projectile.xpos - 64;  }
      
      if(64.0 - (8*GROUND_THICKNESS) - (game.projectile.ypos) > 0 && 64.0 - (8*GROUND_THICKNESS) - (game.projectile.ypos) < 64) { 
        unsigned char xpo = (unsigned char)(game.projectile.xpos - view_x);
        unsigned char ypo = 64 - (8*GROUND_THICKNESS) - ((unsigned char)game.projectile.ypos);
        arduboy.drawRect(xpo,ypo,1,1,WHITE);

      }
    }
  }

  if(game.state & PS_PLAYER_PAN) {
      game.strength = game.strength < 1 ? 0 : game.strength - 1;

      if(game.wind != game.wind_tgt && arduboy.everyXFrames(8)) {
        game.wind += (game.wind < game.wind_tgt) ? 1 : -1;
      }
      
      if(update_dirt() == 0 && game.strength == 0 && game.wind == game.wind_tgt){
        if(game.state & PS_PLAYER_1)  { game.state = PS_PLAYER_2; view_x = 127; }
        else                          { game.state = PS_PLAYER_1; view_x = 0;   }
      }
  }

  
  /*Render the terrain*/
  for(unsigned char i=0; i<17; i++){
    arduboy.drawBitmap(i*8 - (view_x%8),6*8,solid,8,8,WHITE);
    arduboy.drawBitmap(i*8 - (view_x%8),7*8,solid,8,8,WHITE);
  }
  
  for(unsigned char i=view_x; i<view_x+128; i++){
    for(unsigned char j=0;j<MODIFIABLE_DEPTH; j++){
      unsigned char val = getMemAt(i,j);
      if(val == 0xFF) {
        arduboy.drawFastVLine(i-view_x,5*8 - (j)*8,8,WHITE);
      } else if(val == 0x00) {
        
      } else {
        
        arduboy.drawPixel(i-view_x,6*8 - j*8 - 7,val&0x40?WHITE:BLACK);
        arduboy.drawPixel(i-view_x,6*8 - j*8 - 6,val&0x20?WHITE:BLACK);
        arduboy.drawPixel(i-view_x,6*8 - j*8 - 5,val&0x10?WHITE:BLACK);
        arduboy.drawPixel(i-view_x,6*8 - j*8 - 4,val&0x08?WHITE:BLACK);
        arduboy.drawPixel(i-view_x,6*8 - j*8 - 3,val&0x04?WHITE:BLACK);
        arduboy.drawPixel(i-view_x,6*8 - j*8 - 2,val&0x02?WHITE:BLACK);
        arduboy.drawPixel(i-view_x,6*8 - j*8 - 1,val&0x01?WHITE:BLACK);
        
      }
    }
    
  }
  
  //draw the artillery_pieces
  if(view_x < game.player_a.xpos + TANK_WIDTH) { drawArtillery(&(game.player_a),0); }
  if(view_x+128 > game.player_b.xpos) { drawArtillery(&(game.player_b),1); }

  //draw the gui
  arduboy.drawRect(0,0,128,10);
  arduboy.drawRect(10,0,108,10);
  arduboy.drawFastVLine(65,0,10);
  arduboy.setCursor(12,1); arduboy.print(F("pwr"));
  arduboy.setCursor(67,1); arduboy.print(F("wnd"));
  arduboy.drawFastVLine(85,0,10);
  arduboy.drawFastVLine(30,0,10);
  
  
  if((game.state & PS_PROJECTIL_FOLLOW) == 0 && (game.state & PS_PLAYER_PAN) == 0) {
    //draw power bar
    arduboy.fillRect(32,2,game.strength*2,6,WHITE);
    
    //draw player
    if(game.state & PS_PLAYER_1) { arduboy.fillRect(2,2,7,6,WHITE); }
    if(game.state & PS_PLAYER_2) { arduboy.fillRect(119,2,7,6,WHITE); }
  }

  //draw wind
  arduboy.drawFastVLine(100,8,1);
  arduboy.drawFastVLine(102,8,1);

  arduboy.drawFastVLine(101,4,6);
  game.sine_wave = game.sine_wave < 128 ? game.sine_wave + 0.1 : 0;
  unsigned char wind_x = 101 + (game.wind < 0 ? game.wind*2 : 0);
  for( unsigned char iter = 0; iter < abs(game.wind*2); iter++) {
    signed char waver = (game.sine_wave + iter);
    waver = waver % 12;
    waver = waver < 3 ? -1 : waver > 9 ? 0 : waver > 6 ? 1 : 0;
    arduboy.drawFastVLine(wind_x + iter,2 + waver,5);    
  }

  //draw health
  arduboy.drawRect(0,11,game.player_a.max_health+4,7);
  arduboy.drawRect(128-(game.player_b.max_health+4),11,game.player_b.max_health+4,7);
  arduboy.fillRect(2,13,game.player_a.health,3,WHITE);
  arduboy.fillRect(126-game.player_b.health,13,game.player_b.health,3,WHITE);
  
}

void directionForBarrel(Artillery *a, unsigned char is_right, double *bxp, double *byp) {
  double angle = a->angle * 0.0174533;
  *bxp = cos(angle);
  *byp = sin(angle);
  if(is_right==0) { *bxp *= -1; }
}

void drawArtillery(Artillery *a, unsigned char is_right) {
  arduboy.drawRect(a->xpos - view_x, a->ypos - 4, TANK_WIDTH,4,WHITE);  
  arduboy.drawFastHLine(a->xpos - view_x + 2, a->ypos - 5,TANK_WIDTH/2,WHITE);

  arduboy.drawPixel(a->xpos - view_x + 2, a->ypos - 2,WHITE);
  arduboy.drawPixel(a->xpos - view_x + 4, a->ypos - 2,WHITE);

  double bxp, byp;

  directionForBarrel(a,is_right,&bxp,&byp);  


  bxp *= BARREL_LENGTH;
  byp *= BARREL_LENGTH;
  
  arduboy.drawLine(a->xpos - view_x + TANK_WIDTH/2,a->ypos - 5,a->xpos - view_x + TANK_WIDTH/2 - (signed char)bxp,a->ypos - 5 - (signed char)byp,WHITE);
}

double calculate_ai_shot(unsigned char best_power, unsigned char best_angle) {

  Artillery *a = &(game.player_b);
  
  double bxp, byp;
  directionForBarrel(a,0,&bxp,&byp);  

  double xpos = a->xpos  + TANK_WIDTH/2 + (bxp*6.0);
  double ypos = 64 - (8*GROUND_THICKNESS) - a->ypos  + 5 + byp*6;
  
  bxp *= best_power / 2;
  byp *= best_power / 2;

  while(ypos > 0) {
    xpos += bxp;
    ypos += byp;

    if(xpos >= 0 && xpos < LEVEL_WIDTH) {
    
      if(checkMem((unsigned char)xpos,(unsigned char)ypos)==1){
        return xpos;
      }
    }
    
    bxp += ((double)game.wind * 0.01);
    byp -= 0.15;
  }

  return bxp;
}

void handle_ai_play() {
  Artillery *a = &(game.player_b);

  //Ai will attempt AI_TRIES times, and pick the best shot
  signed char best_power = MAX_STRENGTH/2 + MAX_STRENGTH/4;
  signed char best_angle = 45;  

  if(game.strength == 0) {

    double best_x = abs(game.player_a.xpos - calculate_ai_shot(best_power,best_angle));
    
    for(unsigned char iter = 1; iter < AI_TRIES; iter++) {
      signed char next_power = best_power + (rand() % 4) - 2;
      signed char next_angle = best_angle + (rand() % 40) - 20;  
      double next_x = calculate_ai_shot(next_power,next_angle);
      
      if(abs(game.player_a.xpos - next_x) < best_x) {
        best_x = abs(game.player_a.xpos - next_x);  
        best_power = next_power;
        best_angle = next_angle;
      }
    }

    game.ai_angle = best_angle;
    game.ai_power = best_power;
    game.strength = 1;
  }

  else {
  
    //set and fire
    if(arduboy.everyXFrames(4)){
      game.strength = game.strength < game.ai_power ? game.strength + 1 : game.strength > game.ai_power ? game.strength - 1 : game.strength;
      a->angle = a->angle < game.ai_angle ? a->angle + 1 : a->angle > game.ai_angle ? a->angle - 1 : a->angle;
      if(a->angle == game.ai_angle && game.strength == game.ai_power) {
        fire_projectile(a,(game.state & PS_PLAYER_1) ? 0 : 1);  
      }
    }
  }
}

void handle_user_input_for_game() {
  //player 1 or player 2 control
  if(game.state & 0x03){
    
    if((game_state & GS_AI_PLAYER) && (game.state & PS_PLAYER_1)==0) {
      handle_ai_play();
      return;
    }
    
    Artillery *a = game.state & PS_PLAYER_1 ? &(game.player_a) : &(game.player_b);
    if(arduboy.pressed(UP_BUTTON)) { a->angle = a->angle + 1 < 89 ? a->angle + 1 : 89; }
    if(arduboy.pressed(DOWN_BUTTON)) { a->angle = a->angle - 1 > 1 ? a->angle - 1 : 1; }  
    if(arduboy.pressed(LEFT_BUTTON)) { 
      game.strength -= arduboy.everyXFrames(10); 
      game.strength = game.strength < 1 ? 1 : game.strength; 
    }
    if(arduboy.pressed(RIGHT_BUTTON)) { 
      game.strength += arduboy.everyXFrames(10); 
      game.strength = game.strength > MAX_STRENGTH ? MAX_STRENGTH : game.strength; 
    }  
    if(arduboy.pressed(A_BUTTON)) { 
      if(game.strength >= 1) {
        fire_projectile(a,(game.state & PS_PLAYER_1) ? 0 : 1);  
      }
    } 
  }
  
}

void fire_projectile(Artillery *a, unsigned char is_right) {

  game.state &= 0x03;
  game.state |= PS_PROJECTIL_FOLLOW;

  double bxp, byp;
  directionForBarrel(a,is_right?0:1,&bxp,&byp);  

  game.projectile.xpos = a->xpos  + TANK_WIDTH/2 + (bxp*6.0);
  game.projectile.ypos = 64 - (8*GROUND_THICKNESS) - a->ypos  + 5 + byp*6;
  
  bxp *= game.strength / 2;
  byp *= game.strength / 2;

  game.projectile.y_step = byp;
  game.projectile.x_step = bxp;
  game.strength = 0;
}


unsigned char walk_projectile(){

  
      
  unsigned char xp,yp;
  double x1, x2, y1, y2, x, y;

  x1 = game.projectile.xpos;
  x2 = game.projectile.xpos + game.projectile.x_step;
  
  y1 = game.projectile.ypos;
  y2 = game.projectile.ypos + game.projectile.y_step;

  x = (x2-x1)/10.0;
  y = (y2-y1)/10.0;

  xp = (unsigned char)x1;
  yp = (unsigned char)y1;


  for(unsigned char iter=0; iter<10; iter++) {

    /*
      If the projectile hits a set pixel (checkmem)
      Or if the projectile is decending and hits an artillery piece.
      Or if it is below the ground.
    */
     if(checkMem(xp,yp)==1 || (game.projectile.y_step < 0 && (checkArtillery(&(game.player_a),xp,yp) || checkArtillery(&(game.player_b),xp,yp))) || y1 <= 0){ 
      game.projectile.xpos = xp;
      game.projectile.ypos = yp;
      return 1; 
     }
     x1 += x;
     y1 += y; 

     if(x1 < 0) { return 0;}
     if(x1 > LEVEL_WIDTH) { return 0;}
     xp = (unsigned char)x1;
     yp = (unsigned char)y1;
  }

  if(checkMem(xp,yp)==1 || y1 <= 0){ 
    game.projectile.xpos = xp;
    game.projectile.ypos = yp;
    return 1; 
  }


  
  return 0;
}

unsigned char update_projectile() {
  if(game.projectile.ypos < 0) { return 1; } 
  if(game.projectile.xpos < 0 || game.projectile.xpos > LEVEL_WIDTH) { return 1; }

  if(game.projectile.ypos + game.projectile.y_step < MODIFIABLE_DEPTH*8 || game.projectile.ypos < MODIFIABLE_DEPTH*8) {
    if(walk_projectile()) { return 2; }
  }
  
  game.projectile.xpos += game.projectile.x_step;
  game.projectile.ypos += game.projectile.y_step;

  //wind and gravity
  game.projectile.x_step += ((double)game.wind * 0.01);
  game.projectile.y_step -= 0.15;

  if(game.projectile.y_step < -10) { game.projectile.y_step = -10; }

  return 0;
}
void gameLogicLoop(void *)
{
  for (;;) {
    inogameloop(); 
    // ArduinoOTA.handle();
  }
}

void setup() {
  inogamesetup();
  xTaskCreatePinnedToCore(gameLogicLoop, "g", 4096, nullptr, 0, nullptr, 0);
}

void loop() {
	delay(60000);
}
